\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{ulem}
\usepackage{caption}
\parindent0pt
\usepackage{placeins}
\usepackage[usenames,dvipsnames]{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{fixltx2e}
\usepackage{scrpage2}
\usepackage{lastpage}
\clearscrheadfoot
\pagestyle{scrheadings}
\usepackage{glossaries}
\usepackage[
top    = 2.75cm,
bottom = 2.00cm,
left   = 2.50cm,
right  = 2.00cm]{geometry}
\setcounter{secnumdepth}{4}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\newcommand{\executeiffilenewer}[3]{%
\ifnum\pdfstrcmp{\pdffilemoddate{#1}}%
{\pdffilemoddate{#2}}>0%
{\immediate\write18{#3}}\fi%
}
\newcommand{\includesvg}[1]{%
\executeiffilenewer{#1.svg}{#1.pdf}%
{inkscape -z -D --file=#1.pdf --export-pdf=#1.pdf --export-latex}%
\input{#1.pdf_tex}%
}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}



%Bibtex
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
		T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%lslisting
\lstdefinestyle{customjava}{
  	language=Java,
  	frame=tlrb,
  	aboveskip=3mm,
  	belowskip=3mm,
  	showstringspaces=false,
  	columns=flexible,
  	basicstyle={\small\ttfamily},
  	numbers=none,
  	numberstyle=\tiny\color{gray},
  	keywordstyle=\color{purple},
  	commentstyle=\color{dkgreen},
  	stringstyle=\color{blue},
  	breaklines=true,
  	breakatwhitespace=true
  	tabsize=3
}

%WHY IS THIS NOT WORKING???
%\lstset{escapechar=@,style=customjava}

%Cite right
\newcommand{\citeof}[2]{{
		\par \begingroup \leftskip=1cm \noindent \textit 
		''#1'' \cite{#2} \\
		\par \endgroup
	}}
	
% Picture insert (UseCase)
% \insertpicture{mik.png}{Some picture}{\cite{bk_key}}{itm:pic1}{0.5}
\newcommand{\insertpicture}[5]{{
	\begin{figure}[!htb]
		\centering\includegraphics[width=#5\textwidth]{#1}
		\caption[#2 #3]{#2}
		\label{#4}
	\end{figure}
	\FloatBarrier
}}



\begin{document}
\begin{titlepage}
\begin{center}
% Oberer Teil der Titelseite:
\includegraphics[width=0.5\textwidth]{images/logo}\\[1cm]    

\LARGE TGM - HTBLuVA Wien XX \\ IT Department  \\[1.5cm]

% Title
\rule{1.0\textwidth}{1mm}
{ \huge \bfseries \\[0.4cm]  \huge Service Oriented Architecture and Restful Webservice \\ \LARGE Dezsys 08  \\[0.4cm] }

\rule{1.0\textwidth}{1mm}



% Author and supervisor
\noindent 
\vspace{5cm}

\begin{center}
\large
Authors: 
Siegel \textsc{Hannah} \&
Nachname2 \textsc{Vorname2}
\end{center}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\tableofcontents


%HEADER AND FOOTER
\pagenumbering{arabic}
\ohead{\headmark}
\ifoot{Â© Haidn, Siegel}
\ofoot{\pagemark ~of \pageref{LastPage}}

\newpage



\section{Working time}
\begin{center}
\end{center}
\begin{table}[h]
\begin{tabular}{|p{0.5\textwidth}|p{0.1\textwidth}|p{0.2\textwidth}|p{0.2\textwidth}|}
\hline
\textbf{Task}    & \textbf{Person}   & \textbf{Estimated}  & \textbf{Final}\\ \hline \hline

Preparation and Frameworks & Haidn &  60 minutes & 60 minutes  \\ \hline 


Creating the Knowledge base with Hibernate & Haidn &  60   minutes & \textcolor{red}{180 minutes}
   \\ \hline 
   Creating the Knowledge base with Hibernate & Haidn &   & \textcolor{red}{270 minutes}
   \\  

Inserting Test-Data  & Siegel &  30 minutes  &   \textcolor{red}{270 minutes}  \\ \hline 

Testing the Performance  & Siegel &  30  minutes  &  \textcolor{red}{60  minutes}  \\ \hline 

RestFul CRUD Operations & Siegel &  90   minutes & \textcolor{red}{210 minutes} \\  
  & Haidn &  90 minutes  &  270   minutes  \\ \hline 


Generate SOA Webservice & Siegel &  60 minutes &  \textcolor{red}{120 minutes} \\ \hline 

Include SOAP for SOA Webservice & Siegel &  30 minutes &  60 minutes \\ \hline 
Generate WSDL File & Siegel &  30 minutes & \textcolor{green}{10 minutes}  \\ \hline 

Generate Website & Haidn &  60 minutes &  270 minutes \\ \hline 

Generate Client for SOA Webservice & Siegel &  60 minutes & \textcolor{red}{180 minutes} \\ \hline 

Document Datatransfer with SOAP & Siegel &  60 minutes & 30  minutes \\ \hline 

Testing & Siegel &  90  minutes  &  310  minutes  \\  
  & Haidn &  90  minutes  & 300  minutes   \\ \hline 


Documentation  & Siegel &  60 minutes  &  90 minutes  \\  
  & Haidn &  60  minutes  &    \\ \hline 

\hline 

Testing & Siegel &  8 hours  & 22.5   \\  
  & Haidn &  8 hours   & 22.5   \\ \hline 


 \hline 
\textbf{Total Team} & & \textbf{15 hours} &\textbf{45 hours}  \\ \hline 
\end{tabular}
\end{table}

\section{Task description}
For the Company iKnow Systems a Knowledgemanagement like Wikipedia should be done.
\begin{itemize}
\item A data model which performs well should be implemented\\
\textcolor{green}{Datamodel was generated. Performance is fine}
\item A RestFul Webservice should be done as an interface which can Update, Create and Delete an Entry.\\
\textcolor{orange}{Troubles deploying the service using Java EE. Implemented seperated solution.}
\item A SOA Webservie should be done\\
\textcolor{green}{Webservice works, WSDL was generated} \\
\item Generate a Website for using the Webservices\\
\textcolor{green}{Website is up and has a suitable UI.}
\textcolor{red}{Updating entries should be checked again.}
\item Implement a Client which calls the Webservice\\
\textcolor{green}{Client works and CLI works} \\
\textcolor{orange}{Only tested locally, but this was not demanded.}
\item Document the Datatransfer with SOAP\\
\textcolor{green}{Worked with Wireshark}
\item Have a routine for inserting 1000000 Entries \\
\textcolor{green}{Works fine} \\
\end{itemize}
\section{Knowledge Base}
For the Knowledge Base we decided to use Hibernate.
\subsection{Hibernate Configuration}
\begin{lstlisting}[caption=hibernate config xml (hibernate.cfg.xml) entity class, label=hibconf]
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
	<session-factory>
		<!-- Database connection settings -->
 		<property name="hibernate.connection.driver_class"> com.mysql.jdbc.Driver </property>
 		<property name="hibernate.connection.url">jdbc:mysql://10.0.104.150:3306/iknow</property>
		<property name="hibernate.connection.username" >vsdb</property>
		<property name="hibernate.connection.password" >vsdbpassword</property>
		<property name="hibernate.dialect" >org.hibernate.dialect.MySQLDialect</property>	
		<property name="connection.pool_size">5</property>
		<property name="current_session_context_class">thread</property>
		<property name="hibernate.transaction.factory_class">org.hibernate.transaction.JDBCTransactionFactory</property>
		
		<!-- do not set this to create unless you want to create the database -->
		<property name="hibernate.hbm2ddl.auto">update</property>

		<property name="hibernate.jdbc.batch_size">49</property>

		<!-- Logging (if true: it will be logged) -->
		<property name="show_sql">false</property>
		
		<!-- Logging classes -->
		<mapping class="model.KnowledgeBase"/>
		<mapping class="model.Tag"/>
	</session-factory>
</hibernate-configuration>

\end{lstlisting}
\subsection{First Knowledgebase}
At first, we were making a new project, which has already a Hello World Webservice. We copied the hibernate config file from the \textit{Westbahn} project into the \texttt{src} folder.\\
Also, we had to add all the needed libraries, such as the mysql connector and all the hibernate libraries.\\
\\
The first Knowledge Base class can be seen in Listing \ref{KnowledgeBase}.
\begin{lstlisting}[caption=KnowledgeBase entity class, label=KnowledgeBase]
// import statements

@Entity
public class KnowledgeBase {
    @Id
    @GeneratedValue
    private Long ID;

    @Column(unique=true)
    @Size(min=10, max=500)
    private String text;

    @Column(unique=true)
    @Size(min=10, max=50)
    private String topic;

	// constructor, getter and setter
}
\end{lstlisting}
We tested the performance and it was not fine.
It took about 15 minutes to insert 50000 entries and searching the Entries was impossible.
\\
We then decided to change our Data model to two databases: a \texttt{Tag} and a \texttt{KnowledgeBase} Entry.
The Search-performance was a lot better, it worked finally, but inserting the data was slower.
\subsection{Better performance Solution}
We were using the Tag class (Listing \ref{Tag}) to have a Tag saved to an KnowledgeBase. Only the Tag can be searched and the search is a lot faster! Once a tag has been found using the \texttt{selectTags} Query, over the \texttt{getKnowledgeBase} method the KnowledgeBases can be found faster.
\begin{lstlisting}[caption= Tag entity class (selection), label=Tag]
@Entity
@NamedQueries({@NamedQuery(
        name="selectTags",
        query="FROM Tag"
),
        @NamedQuery(
                name="searchTag",
                query="FROM Tag WHERE tagname=:searchstring"
        )})
public class Tag implements ManageableTable{
    @Id
    @GeneratedValue
    private Long ID;

    @Column
    @Size(min=9, max=11)
    private String tagname;

    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL )
    List<KnowledgeBase> knowledgebases;

    public void addKnowledgeBase(KnowledgeBase kb){
        this.knowledgebases.add(kb);
    }
}
\end{lstlisting}
\subsection{Problems}
\begin{itemize}
\item 		The Hibernate Config must be set to update. Only at the first run it should be create. Otherwise the database will be empty: 
\begin{lstlisting}
<property name="hibernate.hbm2ddl.auto">update</property>
\end{lstlisting}
\item The Database must be set 'public'. For this, in the file \texttt{/etc/init.d/my.cnf} the \texttt{bind-address 127.0.0.1} must be commented out.
\item A user mus be generated who has the permission to come from another host: (\cite{hostpermisson})
\begin{lstlisting}
CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' WITH GRANT OPTION;
CREATE USER 'username'@'%' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON *.* TO 'username'@'%' WITH GRANT OPTION;
\end{lstlisting}
\end{itemize}




\section{Build a RESTful WebService}

%"RESTful web services are built to work best on the Web. Representational State Transfer (REST) is an architectural style that specifies constraints, such as the uniform interface, that if applied to a web service induce desirable properties, such as performance, scalability, and modifiability, that enable services to work best on the Web. In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web. The resources are acted upon by using a set of simple, well-defined operations. The REST architectural style constrains an architecture to a client/server architecture and is designed to use a stateless communication protocol, typically HTTP. In the REST architecture style, clients and servers exchange representations of resources by using a standardized interface and protocol."\cite{javaEE6}
%\\\\
REST is an architectural style which is based on web-standards and the HTTP protocol. REST was first described by Roy Fielding in 2000.In a REST based architecture everything is a resource. A resource is accessed via a common interface based on the HTTP standard methods. In a REST based architecture you typically have a REST server which provides access to the resources and a REST client which accesses and modifies the REST resources. Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs). REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation)  \cite{vogella}
\\\\
\textbf{HTTP methods} \\
The PUT, GET, POST and DELETE methods are typical used in REST based architectures.
 \cite{vogella}
\subsection{JAX-RS}
First we decided to use the JAX-RS libary. It works with annotations which seems really easy.
The code could also be generated with IntelliJ but we were not able to find any possibility to deploy it using the IDE and we encountered too many errors. We were also trying an complete tutorial (\cite{vogella}).Still we were not able to solve any of them, we decided to use another language - PHP. An example for an Hello World JAX-RS Webservice can be found in Listing \ref{RFWS}.
\begin{lstlisting}[caption=Restful Webservice, label=RFWS]
@Path("/helloworld")
public class RestfulWebservice {
    @GET
    @Produces("text/plain")
    public String getClichedMessage() {
        return "Hello World!";
    }
}
\end{lstlisting}
\newpage
\subsection{PHP}
To provide a webservice that is able to interact with our knowledge base we decided to use PHP. The topmost used request for our proposes ist GET to interact with the system. The functions are provided using an action tag in the request which allows the following commands:
\begin{enumerate}
	\item add
	\item remove
	\item update
\end{enumerate}
The data structure that comes with our service is defined over a topic, which represents the title of an knowledgebase entry and it's content.\\
The deleting option requres an id that was created by inserting the specific entry.\\
Every function can either return a success message or a failure state.\\
\\
\section{Webservice interface}
The interface of our webservice is written in HTML, CSS and PHP as well. It provides the functionality to list all entries and grafically decide for an action to execute.\\
The changes made using the interface are immediately displayed on the screen. Therefore a heading bar shows the service response after an action was called. Additionally the user has always an overview of the current size of the knowledgebase.



%\textbf{Annotations}\\
%Resource identification through URI: A RESTful web service exposes a set of resources that identify the targets of the interaction with its clients. Resources are identified by URIs, which provide a global addressing space for resource and service discovery. See The @Path Annotation and URI Path Templates for more information.
%\\ \\ \\
%Root resource classes are POJOs that are either annotated with @Path or have at least one method annotated with @Path or a request method designator, such as @GET, @PUT, @POST, or @DELETE. Resource methods are methods of a resource class annotated with a request method designator. This section explains how to use JAX-RS to annotate Java classes to create RESTful web services.\cite{javaEE6}
%\\ \\ \\
%Annotation	Description
%@PATH(your\_path)	Sets the path to base URL + /your\_path. The base URL is based on your application name, the servlet and the URL pattern from the web.xml configuration file.
%@POST	Indicates that the following method will answer to an HTTP POST request.
%@GET	Indicates that the following method will answer to an HTTP GET request.
%@PUT	Indicates that the following method will answer to an HTTP PUT request.
%@DELETE	Indicates that the following method will answer to an HTTP DELETE request.
%@Produces(MediaType.TEXT\_PLAIN[, more-types])	@Produces defines which MIME type is delivered by a method annotated with @GET. In the example text ("text/plain") is produced. Other examples would be "application/xml" or "application/json".
%@Consumes(type[, more-types])	@Consumes defines which MIME type is consumed by this method.
%@PathParam	Used to inject values from the URL into a method parameter. This way you inject, for example, the ID of a resource into the method to get the correct object.
%\\ \\ \\






\newpage
\section{Building the SOA Webservice in Java}
\label{sec:ws}
Because we were using the IntelliJ IDEA, this was quite easy.
A hello world example with jax-ws can be generated under \textit{new project} -\textgreater \textit{Check Webservice } -\textgreater Check \textit{Generate server sample code}. \\
This client code is a Hello World example and can already be run. When we accessed it trough the webbrowser we were able to see some information about the service and the generated wsdl File.\\
\\
Under \cite{mkyongjaxwsexample} we were able to find a complete example, using an interface and more important also a client. So we were changing our code then. We used the hello world example and the tutorial from mkyong to adapt the following classes:\\
\begin{itemize}
\item \texttt{Searchable}-Interface (Listing \ref{Searchable})
\item \texttt{KnowledgeBaseSearcher}-Class which implements the \texttt{Searchable}-Interface and provides the search method (Listing \ref{KnowledgeBaseSearcher})
\item \texttt{KnowledgeBaseSearcherPublisher}-Class which publishes the \texttt{KnowledgeBaseSearcher}-Service  (Listing \ref{KnowledgeBaseSearcherPublisher}). Later this was done by the Starter Class.
\item \texttt{KnowledgeBaseSearcherClient}-Class which is using the service over it's WSDL File (Listing \ref{KnowledgeBaseSearcherClient}). Later this has been done a bit more complicated with a nice CLI.
\end{itemize}
Man muss nun zuerst den \texttt{KnowledgeBaseSearcherPublisher} starten, um das Service zu publishen und das Starten des Clients (\texttt{KnowledgeBaseSearcherClient}) und das unten angegebene Beispiel nun gibt nun
\textit{Return the search query with the search of: blabla} aus.

\begin{lstlisting}[caption=Searchable interface, label=Searchable]
// imports javax.ws.*
@WebService
@SOAPBinding(style = Style.RPC)
public interface Searchable {
    @WebMethod String search(String searchstring);
}
\end{lstlisting}

\begin{lstlisting}[caption=KnowledgeBaseSearcher class, label=KnowledgeBaseSearcher]
// imports javax.ws.*
@WebService(endpointInterface = "soa.Searchable")
public class KnowledgeBaseSearcher implements Searchable{
    @Override
    public String search(String searchstring) {
        return "Return the search query with the search of: "+searchstring;
    }
\end{lstlisting}
\begin{lstlisting}[caption=KnowledgeBaseSearcherPublisher class, label=KnowledgeBaseSearcherPublisher]
public class KnowledgeBaseSearcherPublisher {
    public static void main(String[] args) {
        Endpoint.publish("http://localhost:9999/soa/searcher", new KnowledgeBaseSearcher());
    }
}
\end{lstlisting}
\begin{lstlisting}[caption=KnowledgeBaseSearcherClient class, label=KnowledgeBaseSearcherClient]
public class KnowledgeBaseSearcherClient {
    public static void main(String[] args) throws Exception {
        URL url = new URL("http://localhost:9999/soa/searcher?wsdl");

        //1st argument service URI, refer to wsdl document above
        //2nd argument is service name, refer to wsdl document above
        QName qname = new QName("http://soa/", "KnowledgeBaseSearcherService");

        Service service = Service.create(url, qname);
        Searchable searcher = service.getPort(Searchable.class);

        System.out.println(searcher.search("blabla"));
    }
}
\end{lstlisting}
\subsection{WSDL}
A WSDl File can be generated using IntelliJ. We did: right click onto the KnowledgeBaseService - WebServices - Generate WSDL from Java Code - OK.\\
The WSDL File (Listing \ref{wsdl}) can than be found in the code base.
\begin{lstlisting}[caption=WSDL File for the KnowledgeBaseSearcher class, label=wsdl]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- Generated by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.7-b01  svn-revision#${svn.Last.Changed.Rev}. -->
<definitions targetNamespace="http://soa" name="KnowledgeBaseSearcher" xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:tns="http://soa" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata">
  <import namespace="http://soa/" location="Searchable.wsdl"/>
  <binding name="KnowledgeBaseSearcherBinding" type="ns1:Searchable" xmlns:ns1="http://soa/">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/>
    <operation name="search">
      <soap:operation soapAction=""/>
      <input>
        <soap:body use="literal" namespace="http://soa/"/>
      </input>
      <output>
        <soap:body use="literal" namespace="http://soa/"/>
      </output>
    </operation>
  </binding>
  <service name="KnowledgeBaseSearcher">
    <port name="KnowledgeBaseSearcher" binding="tns:KnowledgeBaseSearcherBinding">
      <soap:address location="http://localhost:8080/services/soa/KnowledgeBaseSearcher"/>
    </port>
  </service>
</definitions>
\end{lstlisting}
\subsection{SOAP}
In order to fetch the SOAP messages, we (Vennesa Belinic and me) used Wireshark. We had to test this over the network which was done using out jar.\FloatBarrier
\begin{figure}[here!]
\centering
\includegraphics[width=0.7\textwidth]{images/wireshark}
\caption{Output of the Wireshark. SOAP can be seen}
\end{figure}\FloatBarrier
\section{Inserting Test Data}
We used the abstract class \texttt{PerformActionOnDatabase} and the more concrete class \texttt{KnowledgeBaseManagement}. \\
The method delete is using a \texttt{ManageableTable} (Interface implemented by the model classes), which provides the method \texttt{getAllQuery}.
\begin{lstlisting}[caption=Deleting all old entries, label=delete]
 public void deleteAll(ManageableTable table){
            //opening Session and Transaction
            Session s = m_sessionFactory.openSession();
            Transaction t = s.beginTransaction();
            t.begin();

            // create query
            org.hibernate.Query q = s.getNamedQuery(table.getAllQuery());

            // run query and fetch result
            List<?> res = q.list();

            for(Object entry: res){
                s.delete(entry);
            }
    }
\end{lstlisting}
In the Listing \ref{generateEntry} an example for generating random inserts is shown.
\begin{lstlisting}[caption=Generating Inserts (as an example), label=generateEntry]
Session s = super.m_sessionFactory.openSession();
Transaction tx = null;
tx = s.beginTransaction();

KnowledgeBase kb;

StringBuilder topic;
StringBuilder text;

Random random = new Random();

for(int i = 0; i < number; ++i){
  topic = new StringBuilder();
  for (int j = 0; j < length1; j++) {
    topic.append(words[random.nextInt(words.length)]+ " ");
  }
  text = new StringBuilder();
  for (int j = 0; j < length2; j++) {
    text.append(words[random.nextInt(words.length)]+ " ");
  }
  kb = new KnowledgeBase(topic.toString(),text.toString());
  s.saveOrUpdate(kb);
}

tx.commit();
s.flush();
s.close();
\end{lstlisting}
\section{Searching}
The Data was searched using the Tag Entity and the users searchstring. The webservice is explained in section \ref{sec:ws}. We used a Name Query for this again and a loop for generating the String as a return type.

\begin{lstlisting}[caption=Search method of the Service, label=generateEntry]

 @Override
    public String search(String searchstring) {
        StringBuilder sb = new StringBuilder();

        // open Session
        Session session = sf.openSession();


        // create query
        Query q = session.getNamedQuery("searchTag");

        // setting parameters
        q.setParameter("searchstring", searchstring);

        long startTime = System.currentTimeMillis();

        // run query and fetch reslut
        List<Tag> res = q.list();

        if (res.size() >= 1) {
            List<KnowledgeBase>kbs = res.get(0).getKnowledgebases();
            kbs.forEach(kb -> {
                sb.append("Knowledge: " + kb.toString());
            });
        }
        
        s = sb.toString();

        long estimatedTime = System.currentTimeMillis() - startTime;

        newString += "Searching took "+estimatedTime/1000 +" seconds\n";

    }
    \end{lstlisting}
\section{Good Performance?}
With our data structure, we inserted 1000000 knowledge base entries. \\
The insert of all the data took about 10 minutes when we tested it.
\\
Because we only search with the Tags, searching takes only about 1 second, which is definitely sufficient performance for us! 

\section{How to run the code}
The jar must only be run and then a CLI will start. Please note that the hibernate config must be set to the right database settings.\\
\\
As an example the following input should be done to both client and searcher if it should work:\\
\texttt{ip-address}\\
\texttt{\textbackslash searcher}\\
\texttt{9999}\\\\
In order to fill the database, the jar must be started as well.

\newpage
\begin{thebibliography}{56}

\bibitem{javaEE6}
   \textbf{The Java EE 6 Tutorial} \\
  \textit{http://docs.oracle.com/javaee/6/tutorial/doc/gijqy.html}
  \newline last used: 06.04.2014, 11:52
  
  \bibitem{vogella}
   \textbf{REST with Java (JAX-RS) using Jersey - Tutorial}, Lars Vogel\\
  \textit{  http://www.vogella.com/tutorials/REST/article.html}
  \newline last used: 11.04.2014, 13:58
  
    
  \bibitem{mkyongjaxwsexample}
   \textbf{JAX-WS Hello World Example â RPC Style}, mkyong ,August 29, 2012\\
  \textit{  http://www.mkyong.com/webservices/jax-ws/jax-ws-hello-world-example/}
  \newline last used: 12.04.2014, 10:36
  
\bibitem{hostpermisson}
   \textbf{Error: Host xxx is not allowed to connect to this MySQL server}\\ Aaditya Bhatt, answered Oct 10 '13 at 6:32\\
  \textit{   http://stackoverflow.com/questions/19288606/error-host-xxx-is-not-allowed-to-connect-to-this-mysql-server\#comment28561857\_19288606
}
  \newline last used: 16.04.2014, 15:06
  

\end{thebibliography}
\end{document}
